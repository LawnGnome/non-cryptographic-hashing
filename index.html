<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Non-cryptographic hashing</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/fonts.css">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="css/sky.css" id="theme">

    <!-- CSS overrides -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/animate.css">
    <link rel="stylesheet" href="css/flowchart.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section class="title">
          <h1>Non-cryptographic hashing</h1>
          <h3>
            Adam Harvey
            <br>
            <a href="https://twitter.com/LGnome">@LGnome</a>
            <br>
            <a href="http://newrelic.com">New Relic</a>
          </h3>
				</section>

        <section>
          <section>
            <h1>What?</h1>
          </section>

          <section>
            <h2>Hash function</h2>
            <aside class="notes">
              Let's start with the obvious: what is a hash function? (Most of
              you likely know this already, but let's make sure we're all on
              the same page.
            </aside>
          </section>

          <section class="input-output">
            <div class="input scroll-4">
              <div>
                <code>Lorem ipsum dolor sit amet,</code>
                <code>consectetur adipiscing elit.</code>
                <code>Integer vitae ex nec nisl</code>
                <code>fermentum sodales in ut lectus.</code>
              </div>
            </div>
            <div style="font-size: 2em">
              <span class="octicon mega-octicon octicon-arrow-down"></span>
            </div>
            <div class="output cycle-4">
              <code>61df8894</code>
              <code>0ec572f8</code>
              <code>19e37640</code>
              <code>372ecf1b</code>
            </div>
            <aside class="notes">
              Fundamentally, a hash function takes any amount of data and
              returns a number based on that data.
            </aside>
          </section>

          <section>
            <h2 id="hash-functions">
              <code>MD5</code>
              <code>SHA-1</code>
              <code>SHA-256</code>
              <code>SHA-512</code>
            </h2>
            <aside class="notes">
              We use them every day. They underpin SSL, block encryption,
              password storage, and many other things that we take for granted.
            </aside>
          </section>

          <section>
            <h2><strong style="opacity: 0">Non-</strong>Cryptographic hash function</h2>
            <aside class="notes">
              All of those are cryptographic hash functions, though. They're
              designed with specific qualities in mind: to make it as difficult
              as possible to generate collisions and to be able to work back to
              find out what the input was. Key derivation functions extend this
              for use with passwords: bcrypt uses the Blowfish block cipher in
              conjunction with a basic hashing function to generate CPU-hard
              hashes based on salted passwords.
            </aside>
          </section>

          <section>
            <h2><strong>Non-</strong>Cryptographic hash function</h2>
            <aside class="notes">
              <p>
                Not all hash functions have to be cryptographic, though.
                There's also a place for functions that are fast and reasonably
                well distributed, but provide no guarantee of security. Some
                can also minimise memory usage.
              </p>
              <p>
                This is the world of the non-cryptographic hash function.
              </p>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>Why?</h1>
          </section>

          <section>
            <h2>What have I seen?</h2>
            <aside class="notes">
              Python provides a set type, but when you're dealing with a lot of
              data you may not want to keep everything in memory. Hashing it
              first can help, particularly if you're doing something that can
              withstand the odd false positive.
            </aside>
          </section>

          <section>
            <h2>Is this valid?</h2>
            <aside class="notes">
              While you'd often need to use a cryptographic hash function for
              checksumming, there are scenarios where you really do just want
              the 2010s version of a parity bit. These can be quick and simple.
            </aside>
          </section>

          <section>
            <h2>Interoperability</h2>
            <aside class="notes">
              People spec weird things all the time. New Relic CAT example.
            </aside>
          </section>

          <section>
            <h2>It's fun?</h2>
          </section>
        </section>

        <section>
          <section>
            <h1>How?</h1>
          </section>

          <section>
            <h2>Goals</h2>
            <ul>
              <li>Fast</li>
              <li>Well distributed output</li>
            </ul>
            <aside class="notes">
              <p>
                There are two key goals. We want something that's quick, and we
                want something that distributes its output well. A common use
                of non-cryptographic hash functions is in implementing hash
                tables &mdash; while that's not usually a huge concern in
                Python, you don't want clumps in your output, because that
                often leads to collisions.
              </p>
            </aside>
          </section>

          <section>
            <h2>Avalanche effect</h2>
            <div class="input">
              <div><code>000<strong>10</strong>000</code></div>
              <div><code>000<strong>01</strong>000</code></div>
              <div><code>000<strong>11</strong>000</code></div>
              <div><code>000<strong>00</strong>000</code></div>
            </div>
            <div style="font-size: 2em">
              <span class="octicon mega-octicon octicon-arrow-down"></span>
            </div>
            <div class="output">
              <code>000<strong>??</strong>00</code>
            </div>
            <aside class="notes">
              This is what you don't want. You want each change to the data to
              have a bigger effect on the output.
            </aside>
          </section>

          <section>
            <h2>Avalanche effect</h2>
            <div class="input">
              <div><code>000<strong>10</strong>000</code></div>
              <div><code>000<strong>01</strong>000</code></div>
              <div><code>000<strong>11</strong>000</code></div>
              <div><code>000<strong>00</strong>000</code></div>
            </div>
            <div style="font-size: 2em">
              <span class="octicon mega-octicon octicon-arrow-down"></span>
            </div>
            <div class="output">
              <code><strong>????????</strong></code>
            </div>
            <aside class="notes">
              Having each change have a large change on the output is called
              the avalanche effect.
            </aside>
          </section>

          <section>
            <pre><code class="python" data-trim>
def hash_function(data: bytes) -&gt; int:
  for chunk in data:
    hash = cleverness(hash, chunk)

  return hash
            </code></pre>
            <aside class="notes">
              <p>
                Broadly, this is how every hash function is constructed. Easy,
                huh? (Python provides a cleverness function, I'm sure.)
                Cleverness is actually a "mixing function": it takes the
                current state and mutates it with the chunk.
              </p>
              <p>
                Chunk sizes vary, but are most commonly bytes or 32-bit words.
              </p>
              <p>
                As an aside, cryptographic hash functions usually use a
                Merkle-Damg√•rd (DAM-gour(d)) construction, which adds padding
                in a specific way, but is otherwise a fancy (and hard) way of
                saying this.
              </p>
            </aside>
          </section>

          <section>
            <h2>Cleverness</h2>
            <ul>
              <li>Unsigned, fixed length integers</li>
              <li>Bitwise operations (<code>xor</code>; bitshifts)</li>
              <li>Multiplication</li>
              <li>Primes</li>
            </ul>
            <aside class="notes">
              The basic constructs that tend to be used. Bitshifts and xor are
              extremely useful when the input has little variance, as they can
              be used to force lots of changes to otherwise unaffected bits.
            </aside>
          </section>

          <section>
            <h2>Integers</h2>
            <pre><code>  0xffffffff
+ 0x00000001
= 0x00000000</code></pre>
            <aside class="notes">
              A brief digression into integers. Python very helpfully provides
              unlimited precision integers, but these constructions generally
              rely on integer overflow: specifically, that integers will wrap
              and only the lowest bits will be preserved.
            </aside>
          </section>

          <section>
            <h2>NumPy</h2>
            <pre><code class="python" data-trim>
from numpy import uint32
            </code></pre>
            <aside class="notes">
              On the bright side, NumPy gives us a good uint32 type that
              supports the semantics we need.
            </aside>
          </section>

          <section>
            <code><pre>&gt;&gt;&gt; from numpy import uint32
&gt;&gt;&gt; a = uint32(42)
&gt;&gt;&gt; a *= 1
&gt;&gt;&gt; print(type(a))
&lt;class 'numpy.<strong>int64</strong>'&gt;</pre></code>
            <aside class="notes">
              Unfortunately, it still autopromotes when you give it Python
              integers.
            </aside>
          </section>

          <section>
            <code><pre>&gt;&gt;&gt; from numpy import uint32
&gt;&gt;&gt; a = uint32(42)
&gt;&gt;&gt; a *= <strong>uint32(1)</strong>
&gt;&gt;&gt; print(type(a))
&lt;class 'numpy.<strong>uint32</strong>'&gt;</pre></code>
            <aside class="notes">
              You're going to see some ugly code. I apologise.
            </aside>
          </section>

          <section>
            <h2>Primes</h2>
            <aside class="notes">
              Most hashing algorithms include one or more (usually more) prime
              numbers as constants. This is mostly for bucketing behaviour: if
              you're using the output to place things into buckets, you don't
              want common factors lest you end up bucketing na√Øvely into the
              same buckets &mdash; if your hash function is biased towards
              multiples of eight and you're implementing something with eight
              buckets, you may not end up using seven of them much.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>FNV-1a</h1>
            <aside class="notes">
              Let's walk through an example: in this case, FNV-1a. FNV was
              created by Glenn Fowler, Landon Curt Noll and Phong Vo in 1991,
              and later revised to improve its avalanche behaviour. It's still
              widely used today, and is simple enough that we can step through
              it and see the principles noted above in action.
            </aside>
          </section>

          <section>
            <h2>FNV-1a</h2>
            <pre><code class="python" data-trim>
def fnv1a32(data: bytes) -&gt; uint32:
  hash = uint32(2166136261)
  for byte in data:
    hash ^= uint32(byte)
    hash *= uint32(16777619)
  return hash
            </code></pre>
            <aside class="notes">
              Here's the Python implementation of the algorithm. Note the ugly
              uint32() calls, as previously threatened. Conceptually, though,
              it's very simple: for each byte (since it's a bytewise
              algorithm), we xor the hash value, then multiply it.
            </aside>
          </section>

          <section>
            <h2>FNV-1a</h2>
            <svg class="flowchart" width="1000" height="500">
              <defs>
                <marker id="arrowhead" markerWidth="6" markerHeight="6" orient="auto" refX="6" refY="3">
                  <path d="M0,0 L6,3 0,6" />
                </marker>
              </defs>

              <rect class="terminal" x="5" y="210" height="80" width="150" rx="20" ry="20" />
              <text class="label" x="80" y="250">data</text>

              <rect class="terminal" x="845" y="210" height="80" width="150" rx="20" ry="20" />
              <text class="label" x="920" y="250">hash</text>

              <rect class="action xor" x="370" y="210" height="80" width="80" />
              <text class="label" x="410" y="250">^</text>

              <rect class="action mult" x="550" y="210" height="80" width="80" />
              <text class="label" x="590" y="250">*</text>

              <line class="arrow" x1="155" y1="250" x2="370" y2="250" />
              <line class="arrow" x1="450" y1="250" x2="550" y2="250" />
              <line class="arrow" x1="630" y1="250" x2="845" y2="250" />
              <path class="arrow" d="M590 290 V 340 C 590 440, 410 440, 410 340 V 290" />
            </svg>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
&gt;   hash = uint32(2166136261)
    for byte in data:
      hash ^= uint32(byte)
      hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1000 0001 0001 1100 1001 1101 1100 0101</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>(unset)</pre></code>
            <aside class="notes">
              First, we set our hash value to a randomly selected number. This
              isn't actually a prime: it's not chosen for its dispersal
              characteristics, but rather is simply a non-zero value so that
              the initial hash value isn't all zeroes. (In fact, it's the FNV-0
              hash of the e-mail signature line of Landon Curt Noll!)
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
&gt;   for byte in data:
      hash ^= uint32(byte)
      hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1000 0001 0001 1100 1001 1101 1100 0101</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 0001</pre></code>
            <aside class="notes">
              Pick a byte (lowercase "a").
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
    for byte in data:
&gt;     hash ^= uint32(byte)
      hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1000 0001 0001 1100 1001 1101 1<strong>01</strong>0 010<strong>0</strong></pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 0001</pre></code>
            <aside class="notes">
              Now we do the exclusive-or. Note that only three bits in hash
              actually changed. Not very avalanchey!
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
    for byte in data:
      hash ^= uint32(byte)
&gt;     hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1<strong>11</strong>0 0<strong>1</strong>0<strong>0</strong> 000<strong>0</strong> 1100 <strong>0</strong>0<strong>10</strong> 1<strong>0</strong>01 <strong>001</strong>0 <strong>1</strong>100</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 0001</pre></code>
            <aside class="notes">
              Now we see some changes! The sharp of eye would have noticed that
              this prime is close to 2^24, which means that we're effectively
              performing a bitshift with some added noise in the lower bits.
              There's some avalanche.
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
&gt;   for byte in data:
      hash ^= uint32(byte)
      hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1110 0100 0000 1100 0010 1001 0010 1100</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 00<strong>10</strong></pre></code>
            <aside class="notes">
              Now we do it again with b, which is only two bits different from
              a.
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
    for byte in data:
&gt;     hash ^= uint32(byte)
      hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre>1110 0100 0000 1100 0010 1001 0<strong>10</strong>0 11<strong>1</strong>0</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 0001</pre></code>
            <aside class="notes">
              Again, only three bits change when we do the xor.
            </aside>
          </section>

          <section>
            <h3><code>fnv1a32(b"ab")</code></h3>
            <pre><code class="python">  def fnv1a32(data: bytes) -&gt; uint32:
    hash = uint32(2166136261)
    for byte in data:
      hash ^= uint32(byte)
&gt;     hash *= uint32(16777619)
    return hash</code></pre>
            <h4><code>hash</code> (binary):</h4>
            <code><pre><strong>0</strong>1<strong>0</strong>0 <strong>1</strong>10<strong>1</strong> 00<strong>1</strong>0 <strong>0</strong>10<strong>1</strong> 00<strong>0</strong>0 <strong>01</strong>01 <strong>1</strong>100 1<strong>0</strong>10</pre></code>
            <h4><code>byte</code> (binary):</h4>
            <code><pre>0000 0000 0000 0000 0000 0000 0110 0001</pre></code>
            <aside class="notes">
              You can see how well distributed the changes are, even after only
              two bytes of input. Every nibble has one or two bits modified. A
              small change resulted in a big change.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>Shootout</h1>
            <aside class="notes">
              Let's look at a few functions (specifically, the 32 bit versions
              where appropriate). Firstly, though, we need a way to compare
              them.
            </aside>
          </section>

          <section>
            <h2>Goals</h2>
            <ul>
              <li>Fast</li>
              <li>Well distributed output</li>
            </ul>
            <aside class="notes">
              Let's look at our goals again. How can we judge them?
            </aside>
          </section>

          <section>
            <h2>Fast</h2>
            <aside class="notes">
              Fast is easy. CPU time pretty much tells us that.
            </aside>
          </section>

          <section>
            <h2>Distribution</h2>
            <aside class="notes">
              We can look at collisions. I'm going to test each algorithm we
              look at against two input sets: OS X's /usr/share/dict/words, and
              the numbers 0-1000000 represented as strings.
            </aside>
          </section>
        </section>
      </div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				center: true,
        width: 1024,
        height: 768,

				transition: 'fade', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
<!-- vim: set nocin ai et ts=2 sw=2: -->

<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Non-cryptographic hashing</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/fonts.css">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="css/sky.css" id="theme">

    <!-- CSS overrides -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/animate.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section class="title">
          <h1>Non-cryptographic hashing</h1>
          <h3>
            Adam Harvey
            <br>
            <a href="https://twitter.com/LGnome">@LGnome</a>
            <br>
            <a href="http://newrelic.com">New Relic</a>
          </h3>
				</section>

        <section>
          <section>
            <h1>What?</h1>
          </section>

          <section>
            <h2>Hash function</h2>
            <aside class="notes">
              Let's start with the obvious: what is a hash function? (Most of
              you likely know this already, but let's make sure we're all on
              the same page.
            </aside>
          </section>

          <section class="input-output">
            <div class="input scroll-4">
              <div>
                <code>Lorem ipsum dolor sit amet,</code>
                <code>consectetur adipiscing elit.</code>
                <code>Integer vitae ex nec nisl</code>
                <code>fermentum sodales in ut lectus.</code>
              </div>
            </div>
            <div style="font-size: 2em">
              <span class="octicon mega-octicon octicon-arrow-down"></span>
            </div>
            <div class="output cycle-4">
              <code>61df8894</code>
              <code>0ec572f8</code>
              <code>19e37640</code>
              <code>372ecf1b</code>
            </div>
            <aside class="notes">
              Fundamentally, a hash function takes any amount of data and
              returns a number based on that data.
            </aside>
          </section>

          <section>
            <h2 id="hash-functions">
              <code>MD5</code>
              <code>SHA-1</code>
              <code>SHA-256</code>
              <code>SHA-512</code>
            </h2>
            <aside class="notes">
              We use them every day. They underpin SSL, block encryption,
              password storage, and many other things that we take for granted.
            </aside>
          </section>

          <section>
            <h2><strong style="opacity: 0">Non-</strong>Cryptographic hash function</h2>
            <aside class="notes">
              All of those are cryptographic hash functions, though. They're
              designed with specific qualities in mind: to make it as difficult
              as possible to generate collisions and to be able to work back to
              find out what the input was. Key derivation functions extend this
              for use with passwords: bcrypt uses the Blowfish block cipher in
              conjunction with a basic hashing function to generate CPU-hard
              hashes based on salted passwords.
            </aside>
          </section>

          <section>
            <h2><strong>Non-</strong>Cryptographic hash function</h2>
            <aside class="notes">
              <p>
                Not all hash functions have to be cryptographic, though.
                There's also a place for functions that are fast and reasonably
                well distributed, but provide no guarantee of security. Some
                can also minimise memory usage.
              </p>
              <p>
                This is the world of the non-cryptographic hash function.
              </p>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>Why?</h1>
          </section>

          <section>
            <h2>What have I seen?</h2>
            <aside class="notes">
              Python provides a set type, but when you're dealing with a lot of
              data you may not want to keep everything in memory. Hashing it
              first can help, particularly if you're doing something that can
              withstand the odd false positive.
            </aside>
          </section>

          <section>
            <h2>Is this valid?</h2>
            <aside class="notes">
              While you'd often need to use a cryptographic hash function for
              checksumming, there are scenarios where you really do just want
              the 2010s version of a parity bit. These can be quick and simple.
            </aside>
          </section>

          <section>
            <h2>Interoperability</h2>
            <aside class="notes">
              People spec weird things all the time. New Relic CAT example.
            </aside>
          </section>

          <section>
            <h2>It's fun?</h2>
          </section>
        </section>

        <section>
          <section>
            <h1>How?</h1>
          </section>

          <section>
            <pre><code class="python" data-trim>
def hash_function(data: bytes) -&gt; int:
  for chunk in data:
    hash = cleverness(hash, chunk)

  return hash
            </code></pre>
            <aside class="notes">
              <p>
                Broadly, this is how every hash function is constructed. Easy,
                huh? (Python provides a cleverness function, I'm sure.)
              </p>
              <p>
                Chunk sizes vary, but are most commonly bytes or 32-bit words.
              </p>
              <p>
                As an aside, cryptographic hash functions usually use a
                Merkle-Damg√•rd (DAM-gour(d)) construction, which adds padding
                in a specific way, but is otherwise a fancy (and hard) way of
                saying this.
              </p>
            </aside>
          </section>

          <section>
            <h2>Cleverness</h2>
            <ul>
              <li>Unsigned, fixed length integers</li>
              <li>Bitwise operations (especially <code>xor</code>)</li>
              <li>Multiplication</li>
              <li>Modulo</li>
            </ul>
          </section>

          <section>
            <h2>Integers</h2>
            <pre><code>  0xffffffff
+ 0x00000001
= 0x00000000</code></pre>
            <aside class="notes">
              A brief digression into integers. Python very helpfully provides
              unlimited precision integers, but these constructions generally
              rely on integer overflow: specifically, that integers will wrap
              and only the lowest bits will be preserved.
            </aside>
          </section>

          <section>
            <h2>NumPy</h2>
            <pre><code class="python" data-trim>
from numpy import uint32
            </code></pre>
            <aside class="notes">
              On the bright side, NumPy gives us a good uint32 type that
              supports the semantics we need.
            </aside>
          </section>

          <section>
            <code><pre>&gt;&gt;&gt; from numpy import uint32
&gt;&gt;&gt; a = uint32(42)
&gt;&gt;&gt; a *= 1
&gt;&gt;&gt; print(type(a))
&lt;class 'numpy.<strong>int64</strong>'&gt;</pre></code>
            <aside class="notes">
              Unfortunately, it still autopromotes when you give it Python
              integers.
            </aside>
          </section>

          <section>
            <code><pre>&gt;&gt;&gt; from numpy import uint32
&gt;&gt;&gt; a = uint32(42)
&gt;&gt;&gt; a *= <strong>uint32(1)</strong>
&gt;&gt;&gt; print(type(a))
&lt;class 'numpy.<strong>uint32</strong>'&gt;</pre></code>
            <aside class="notes">
              You're going to see some ugly code. I apologise.
            </aside>
          </section>
        </section>
      </div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				center: true,
        width: 1024,
        height: 768,

				transition: 'fade', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
<!-- vim: set nocin ai et ts=2 sw=2: -->
